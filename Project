local Players = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")

local GAMES = {
    TouchFootball = 16447934574,
    Arsenal = 286090429,
    Counterblox = 301549746,
    RFL = 70539431141054,
    RF24 = 14004668761
}

local currentPlaceId = game.PlaceId

local function notify(title, message, duration)
    game:GetService("StarterGui"):SetCore("SendNotification", {
        Title = title;
        Text = message;
        Duration = duration or 5;
    })
end

notify("Game Detector", "Detecting game...", 3)

wait(1)

local function loadRFL()
    notify("Game Detected", "RFL/RF24 - Loading Cobalt Hub...", 3)
    wait(0.5)

    repeat task.wait() until game:IsLoaded()

    local gmt = getrawmetatable(game)
    local setreadonly = setreadonly or make_writeable or function() end
    local getnamecallmethod = getnamecallmethod or get_namecall_method
    local newcclosure = newcclosure or function(f) return f end

    pcall(function()
        setreadonly(gmt, false)
        local blocked = {"Kick", "Ban"}
        local old = gmt.__namecall
        gmt.__namecall = newcclosure(function(self, ...)
            local method = getnamecallmethod()
            if table.find(blocked, method) then return end
            if method == "FireServer" or method == "InvokeServer" then
                local name = tostring(self):lower()
                if name:match("anti") or name:match("detect") or name:match("flag") then return end
            end
            return old(self, ...)
        end)
        setreadonly(gmt, true)
    end)

    task.wait(0.5)

    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local Workspace = game:GetService("Workspace")
    local HttpService = game:GetService("HttpService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local CollectionService = game:GetService("CollectionService")
    local player = Players.LocalPlayer

    local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()

    local Window = Fluent:CreateWindow({
        Title = "Cobalt Hub - RFL/RF24",
        SubTitle = "by rapidkuba",
        TabWidth = 160,
        Size = UDim2.fromOffset(580, 460),
        Acrylic = true,
        Theme = "Dark"
    })

    local Tabs = {
        Main = Window:AddTab({ Title = "Main", Icon = "" }),
        Ball = Window:AddTab({ Title = "Ball", Icon = "" }),
        Game = Window:AddTab({ Title = "Game", Icon = "" }),
        Settings = Window:AddTab({ Title = "Settings", Icon = "" })
    }

    local config = {
        visOn = false,
        reachX = 7.5,
        reachY = 7.5,
        reachZ = 7.5,
        offsetX = 0,
        offsetY = 0,
        offsetZ = 0,
        infStamOn = false,
        antiOutOn = false,
        ballPredictOn = false,
        autoGoal = false,
        ballPredictColor = Color3.fromRGB(100, 180, 255)
    }

    pcall(function()
        for _, v in ipairs(getgc(true)) do
            if type(v) == "table" and rawget(v, "gkCheck") then
                pcall(function()
                    for index, constant in debug.getconstants(v.react) do
                        if constant == "ignoreReactDecline" then
                            debug.setconstant(v.react, index, "ball")
                        end
                        if constant == "specialTool" then
                            debug.setconstant(v.react, index, "ball")
                        end
                    end
                end)
                
                pcall(function()
                    rawset(v, "overlapCheck", function() return true end)
                end)
                
                pcall(function()
                    rawset(v, "check", function() return true end)
                end)
                break
            end
        end
    end)

    local cBalls = {}

    local function addBall(object)
        if object:IsA("BasePart") then
            table.insert(cBalls, object)
        end
    end

    for _, object in pairs(CollectionService:GetTagged("Ball")) do
        addBall(object)
    end

    CollectionService:GetInstanceAddedSignal("Ball"):Connect(addBall)
    CollectionService:GetInstanceRemovedSignal("Ball"):Connect(function(object)
        if table.find(cBalls, object) then
            table.remove(cBalls, table.find(cBalls, object))
        end
    end)

    local function getBalls()
        local balls = {}
        pcall(function()
            for _, obj in ipairs(Workspace.game:GetDescendants()) do
                if obj:IsA("BasePart") and (obj:GetAttribute("networkOwner") or obj:GetAttribute("lastTouch") or obj.Name:lower():find("ball")) then
                    table.insert(balls, obj)
                end
            end
        end)
        if #balls == 0 then
            for _, obj in ipairs(cBalls) do
                if obj and obj.Parent then
                    table.insert(balls, obj)
                end
            end
        end
        return balls
    end

    Tabs.Main:AddToggle("VisualizerToggle", {
        Title = "Visualizer",
        Default = false,
        Callback = function(val)
            config.visOn = val
        end
    })

    Tabs.Main:AddSlider("ReachXSlider", {
        Title = "Reach X",
        Description = "horizontal reach size",
        Default = 7.5,
        Min = 1,
        Max = 12.5,
        Rounding = 1,
        Callback = function(val)
            config.reachX = val
        end
    })

    Tabs.Main:AddSlider("ReachYSlider", {
        Title = "Reach Y",
        Description = "vertical reach size",
        Default = 7.5,
        Min = 1,
        Max = 12.5,
        Rounding = 1,
        Callback = function(val)
            config.reachY = val
        end
    })

    Tabs.Main:AddSlider("ReachZSlider", {
        Title = "Reach Z",
        Description = "depth reach size",
        Default = 7.5,
        Min = 1,
        Max = 12.5,
        Rounding = 1,
        Callback = function(val)
            config.reachZ = val
        end
    })

    Tabs.Main:AddSlider("OffsetXSlider", {
        Title = "Offset X",
        Description = "horizontal offset",
        Default = 0,
        Min = -50,
        Max = 50,
        Rounding = 0,
        Callback = function(val)
            config.offsetX = val
        end
    })

    Tabs.Main:AddSlider("OffsetYSlider", {
        Title = "Offset Y",
        Description = "vertical offset",
        Default = 0,
        Min = -50,
        Max = 50,
        Rounding = 0,
        Callback = function(val)
            config.offsetY = val
        end
    })

    Tabs.Main:AddSlider("OffsetZSlider", {
        Title = "Offset Z",
        Description = "depth offset",
        Default = 0,
        Min = -50,
        Max = 50,
        Rounding = 0,
        Callback = function(val)
            config.offsetZ = val
        end
    })

    Tabs.Main:AddToggle("InfStaminaToggle", {
        Title = "Infinite Stamina",
        Default = false,
        Callback = function(val)
            config.infStamOn = val
        end
    })

    Tabs.Ball:AddToggle("BallPredictToggle", {
        Title = "Ball Predictor",
        Description = "shows ball trajectory",
        Default = false,
        Callback = function(val)
            config.ballPredictOn = val
        end
    })

    Tabs.Ball:AddToggle("AutoGoalToggle", {
        Title = "Auto Goal",
        Description = "automatically scores goals",
        Default = false,
        Callback = function(val)
            config.autoGoal = val
            Fluent:Notify({
                Title = "Auto Goal",
                Content = (val and "Enabled" or "Disabled"),
                Duration = 2
            })
        end
    })

    Tabs.Game:AddToggle("AntiOutToggle", {
        Title = "Anti-Out",
        Description = "prevents out of bounds",
        Default = false,
        Callback = function(val)
            config.antiOutOn = val
        end
    })

    Tabs.Game:AddButton({
        Title = "Match Settings",
        Description = "open match settings",
        Callback = function()
            pcall(function()
                player:WaitForChild("PlayerScripts"):WaitForChild("visuals"):WaitForChild("matchSettings"):SetAttribute("toggle", true)
            end)
            Fluent:Notify({
                Title = "Match Settings",
                Content = "Toggled!",
                Duration = 2
            })
        end
    })

    Tabs.Game:AddButton({
        Title = "Pitch Teleport",
        Description = "teleport to pitch",
        Callback = function()
            pcall(function()
                local net = ReplicatedStorage:FindFirstChild("network")
                if net and net:FindFirstChild("Shared") then
                    for _, re in pairs(net.Shared:GetChildren()) do
                        if re:IsA("RemoteEvent") then 
                            re:FireServer(1000, "pitchTeleporter") 
                            Fluent:Notify({
                                Title = "Teleport",
                                Content = "Teleported to pitch!",
                                Duration = 2
                            })
                            break 
                        end
                    end
                end
            end)
        end
    })

    Tabs.Settings:AddButton({
        Title = "Rejoin Server",
        Description = "rejoins current server",
        Callback = function()
            TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, player)
        end
    })

    Tabs.Settings:AddButton({
        Title = "Server Hop",
        Description = "joins a different server",
        Callback = function()
            pcall(function()
                local servers = {}
                local req = HttpService:JSONDecode(game:HttpGetAsync("https://games.roblox.com/v1/games/"..game.PlaceId.."/servers/Public?sortOrder=Asc&limit=100"))
                if req and req.data then
                    for _, srv in pairs(req.data) do
                        if srv.id ~= game.JobId and srv.playing < srv.maxPlayers then
                            table.insert(servers, srv.id)
                        end
                    end
                end
                if #servers > 0 then
                    TeleportService:TeleportToPlaceInstance(game.PlaceId, servers[math.random(1,#servers)], player)
                end
            end)
        end
    })

    Tabs.Settings:AddParagraph({
        Title = "Discord",
        Content = "Join our discord server for updates and support"
    })

    Tabs.Settings:AddButton({
        Title = "Copy Discord",
        Description = "copies discord invite",
        Callback = function()
            setclipboard("https://discord.gg/4RR8WXwdAx")
            Fluent:Notify({
                Title = "Copied!",
                Content = "Discord invite copied to clipboard",
                Duration = 3
            })
        end
    })

    local char = player.Character or player.CharacterAdded:Wait()
    local hrp = char:WaitForChild("HumanoidRootPart")

    player.CharacterAdded:Connect(function(c)
        char = c
        hrp = c:WaitForChild("HumanoidRootPart")
    end)

    local hitbox = Instance.new("Part")
    hitbox.Name = "ReachBox"
    hitbox.Anchored = true
    hitbox.CanCollide = false
    hitbox.Transparency = 1
    hitbox.Parent = Workspace

    local box = Instance.new("SelectionBox")
    box.Adornee = hitbox
    box.LineThickness = 0.05
    box.Color3 = Color3.fromRGB(70, 130, 180)
    box.Transparency = 1
    box.Parent = hitbox

    local particles = Instance.new("ParticleEmitter")
    particles.Texture = "rbxassetid://243660364"
    particles.Lifetime = NumberRange.new(0.4)
    particles.Rate = 40
    particles.Speed = NumberRange.new(2)
    particles.Color = ColorSequence.new(Color3.fromRGB(70, 130, 180))
    particles.Transparency = NumberSequence.new(0.4, 1)
    particles.LightEmission = 1
    particles.Enabled = false
    particles.Parent = hitbox

    local outstore = {}

    local function getTeam()
        if not player.Team then return "Home" end
        local team = string.split(player.Team.Name, " ")[1]
        return team == "Home" and "Away" or "Home"
    end

    local function getGoal()
        for _, object in pairs(Workspace.game:GetChildren()) do
            if object.Name == "system" and object:FindFirstChild("goal") then
                return object.goal[getTeam()]
            end
        end
    end

    local activeBallTracking = {}

    local function getTB(ball)
        local goal = getGoal()
        if not goal then return ball.Position + Vector3.new(0, 10, 0) end
        
        local goalCenter = goal.Position
        local targetY = goalCenter.Y + (goal.Size.Y / 3)
        local sideOffset = (goal.Size.X / 3)
        local leftOrRight = math.random() > 0.5 and 1 or -1
        local lateralOffset = goal.CFrame.RightVector * (sideOffset * leftOrRight)
        
        local targetPos = Vector3.new(
            goalCenter.X + lateralOffset.X,
            targetY,
            goalCenter.Z + lateralOffset.Z
        )
        
        return targetPos
    end

    local function getAGVector(ball, targetPos)
        local ballPos = ball.Position
        local direction = (targetPos - ballPos).Unit
        local speed = 350
        return direction * speed
    end

    pcall(function()
        local ballsFolder = CollectionService:GetTagged("BallsFolder")[1]
        if ballsFolder then
            ballsFolder.DescendantAdded:Connect(function(bodyVel)
                if not config.autoGoal then return end
                if not bodyVel:IsA("BodyVelocity") then return end
                if not bodyVel.Parent:IsA("BasePart") then return end
                if activeBallTracking[bodyVel.Parent] then return end
                
                local hasKickTool = false
                if char then
                    for _, tool in pairs(char:GetChildren()) do
                        if tool:IsA("Tool") and tool.Name:lower():find("kick") then
                            hasKickTool = true
                            break
                        end
                    end
                end
                
                if not hasKickTool then return end
                
                task.spawn(function()
                    repeat task.wait() until bodyVel.Velocity ~= Vector3.new(0, 2, 0)
                    
                    local ball = bodyVel.Parent
                    if not ball or not ball.Parent then return end
                    
                    activeBallTracking[ball] = true
                    
                    for i = 1, 3 do
                        pcall(function() ball:SetNetworkOwner(player) end)
                        task.wait(0.02)
                    end
                    
                    task.wait(0.05)
                    
                    for _, object in pairs(ball:GetChildren()) do
                        if object:IsA("BodyMover") then
                            pcall(function() object:Destroy() end)
                        end
                    end
                    
                    task.wait(0.02)
                    
                    local targetPos = getTB(ball)
                    
                    local newBodyVel = Instance.new("BodyVelocity")
                    newBodyVel.Name = "AutoGoalVelocity"
                    newBodyVel.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                    newBodyVel.Velocity = getAGVector(ball, targetPos)
                    newBodyVel.P = 50000
                    newBodyVel.Parent = ball
                    
                    local antiGrav = Instance.new("BodyForce")
                    antiGrav.Name = "AutoGoalAntiGrav"
                    antiGrav.Force = Vector3.new(0, ball:GetMass() * Workspace.Gravity * 1.1, 0)
                    antiGrav.Parent = ball
                    
                    local startTime = tick()
                    local maxDuration = 2.5
                    local lastUpdate = tick()
                    
                    local connection
                    connection = RunService.Heartbeat:Connect(function()
                        if not ball or not ball.Parent or not newBodyVel or not newBodyVel.Parent then
                            if connection then connection:Disconnect() end
                            activeBallTracking[ball] = nil
                            return
                        end
                        
                        if tick() - startTime > maxDuration then
                            if connection then connection:Disconnect() end
                            if newBodyVel and newBodyVel.Parent then newBodyVel:Destroy() end
                            if antiGrav and antiGrav.Parent then antiGrav:Destroy() end
                            activeBallTracking[ball] = nil
                            return
                        end
                        
                        if tick() - lastUpdate > 0.1 then
                            pcall(function()
                                local distanceToGoal = (ball.Position - targetPos).Magnitude
                                if distanceToGoal < 5 then
                                    if connection then connection:Disconnect() end
                                    if newBodyVel and newBodyVel.Parent then newBodyVel:Destroy() end
                                    if antiGrav and antiGrav.Parent then antiGrav:Destroy() end
                                    activeBallTracking[ball] = nil
                                    return
                                end
                                newBodyVel.Velocity = getAGVector(ball, targetPos)
                            end)
                            lastUpdate = tick()
                        end
                    end)
                    
                    task.delay(maxDuration, function()
                        if connection then connection:Disconnect() end
                        if newBodyVel and newBodyVel.Parent then
                            newBodyVel:Destroy()
                        end
                        if antiGrav and antiGrav.Parent then
                            antiGrav:Destroy()
                        end
                        activeBallTracking[ball] = nil
                    end)
                end)
            end)
        end
    end)

    RunService.Heartbeat:Connect(function()
        pcall(function()
            if not char or not char.Parent then
                char = player.Character
            end
            if not char then return end
            
            if not hrp or not hrp.Parent then
                hrp = char:FindFirstChild("HumanoidRootPart")
            end
            if not hrp then return end
            
            local balls = getBalls()

            if config.visOn and #balls > 0 then
                hitbox.CFrame = hrp.CFrame * CFrame.new(config.offsetX, config.offsetY, config.offsetZ)
                hitbox.Size = Vector3.new(config.reachX, config.reachY, config.reachZ)
                box.Transparency = 0.6
                particles.Enabled = true
            else
                box.Transparency = 1
                particles.Enabled = false
            end

            if config.infStamOn then
                pcall(function()
                    local ps = player:FindFirstChild("PlayerScripts")
                    if ps then
                        local c = ps:FindFirstChild("controllers")
                        if c then
                            local m = c:FindFirstChild("movementController")
                            if m and m:FindFirstChild("stamina") then
                                m.stamina.Value = 100
                            end
                        end
                    end
                end)
            end

            if config.antiOutOn then
                local out = Workspace:FindFirstChild("game") and Workspace.game:FindFirstChild("system") and Workspace.game.system:FindFirstChild("out")
                if out then
                    for _, part in ipairs(out:GetChildren()) do
                        if table.find({"AwayLeft","AwayRight","HomeLeft","HomeRight","ThrowInFarSide","ThrowInTunnelSide"}, part.Name) then
                            if not outstore[part.Name] then
                                outstore[part.Name] = part.Parent
                                part.Parent = nil
                            end
                        end
                    end
                end
            else
                for name, parent in pairs(outstore) do
                    local out = Workspace:FindFirstChild("game") and Workspace.game:FindFirstChild("system") and Workspace.game.system:FindFirstChild("out")
                    if out then
                        local part = out:FindFirstChild(name)
                        if part then part.Parent = parent end
                    end
                end
                outstore = {}
            end

            if config.ballPredictOn and #balls > 0 then
                task.spawn(function()
                    pcall(function()
                        for _, v in pairs(Workspace:GetChildren()) do
                            if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("CobaltPred") then v:Destroy() end
                        end

                        table.sort(balls, function(a, b)
                            return (a.Position - hrp.Position).Magnitude < (b.Position - hrp.Position).Magnitude
                        end)

                        local ball = balls[1]
                        if not ball or ball.AssemblyLinearVelocity.Magnitude < 5 then return end

                        local pos = ball.Position
                        local vel = ball.AssemblyLinearVelocity
                        local grav = Workspace.Gravity
                        local ground = hrp.Position.Y - 2
                        local points = {}

                        for i = 1, 25 do
                            local t = i * 0.1
                            local futurePos = pos + (vel * t) + Vector3.new(0, -0.5 * grav * t * t, 0)
                            if futurePos.Y <= ground then
                                table.insert(points, Vector3.new(futurePos.X, ground, futurePos.Z))
                                break
                            else
                                table.insert(points, futurePos)
                            end
                        end

                        if #points < 2 then return end

                        for i = 1, #points - 1 do
                            local att0 = Instance.new("Attachment")
                            att0.Name = "CobaltPredAttach"
                            att0.WorldPosition = points[i]
                            att0.Parent = Workspace.Terrain

                            local att1 = Instance.new("Attachment")
                            att1.Name = "CobaltPredAttach"
                            att1.WorldPosition = points[i + 1]
                            att1.Parent = Workspace.Terrain

                            local beam = Instance.new("Beam")
                            beam.Name = "CobaltPred"
                            beam.Attachment0 = att0
                            beam.Attachment1 = att1
                            beam.Color = ColorSequence.new(config.ballPredictColor)
                            beam.Width0 = 0.3
                            beam.Width1 = 0.3
                            beam.FaceCamera = true
                            beam.Transparency = NumberSequence.new(0.3)
                            beam.Parent = Workspace
                        end

                        task.delay(2, function()
                            for _, v in pairs(Workspace:GetChildren()) do
                                if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("CobaltPred") then v:Destroy() end
                            end
                        end)
                    end)
                end)
            else
                for _, v in pairs(Workspace:GetChildren()) do
                    if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("CobaltPred") then v:Destroy() end
                end
            end
        end)
    end)

    notify("âœ“ Loaded", "Cobalt Hub RFL/RF24 loaded successfully!", 3)
    print("Cobalt Hub RFL/RF24 loaded successfully!")
end

if currentPlaceId == GAMES.RFL or currentPlaceId == GAMES.RF24 then
    loadRFL()
else
    notify("Unsupported Game", "This game is not supported!\nPlaceID: " .. tostring(currentPlaceId), 10)
    warn("Unsupported game detected. Current PlaceId:", currentPlaceId)
    warn("Supported games:")
    for name, id in pairs(GAMES) do
        warn(string.format("  - %s: %d", name, id))
    end
end
