
local HttpService = game:GetService("HttpService")
local Market = game:GetService("MarketplaceService")
local Player = game.Players.LocalPlayer
local HWID = game:GetService("RbxAnalyticsService"):GetClientId()
local DiscordWebhook = "https://discord.com/api/webhooks/1459573854568710341/hnTvq0FeZVCEHbVx9Uicx4Jp0LfNgNNvqI01mUwVlY0RXFOivRVSqUz0xGbEQIFMKgBA"

local function SendWebhook(Status)
    local request = (syn and syn.request) or (http and http.request) or http_request or (fluxus and fluxus.request) or request
    if request then
        task.spawn(function()
            pcall(function()
                local GameName = Market:GetProductInfo(game.PlaceId).Name
                local executor = (identifyexecutor and identifyexecutor()) or "Unknown"
                local headshot = "https://www.roblox.com/headshot-thumbnail/image?userId="..Player.UserId.."&width=420&height=420&format=png"
                
                request({
                    Url = DiscordWebhook,
                    Method = "POST",
                    Headers = {["Content-Type"] = "application/json"},
                    Body = HttpService:JSONEncode({
                        ["embeds"] = {{
                            ["title"] = "‚ù§Ô∏è‚Äçü©π [ SCRIPT EXECUTION made by vestro ]",
                            ["description"] = "**Current Status:** " .. Status,
                            ["color"] = 65280, 
                            ["thumbnail"] = {["url"] = headshot},
                            ["fields"] = {
                                {["name"] = "üë§ User", ["value"] = Player.DisplayName .. " (ID: " .. Player.UserId .. ")", ["inline"] = false},
                                {["name"] = "‚öôÔ∏è Executor", ["value"] = "```" .. executor .. "```", ["inline"] = false},
                                {["name"] = "üéÆ Game", ["value"] = GameName, ["inline"] = false},
                                {["name"] = "üÜî HWID", ["value"] = "```" .. HWID .. "```", ["inline"] = false},
                                {["name"] = "üîó Links", ["value"] = "[Profile](https://www.roblox.com/users/"..Player.UserId.."/profile) | [Join Server](https://www.roblox.com/games/"..game.PlaceId..")", ["inline"] = false}
                            },
                            ["footer"] = {["text"] = "Vestro Security ‚Ä¢ " .. os.date("%X")},
                            ["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ")
                        }}
                    })
                })
            end)
        end)
    end
end

SendWebhook("Script Executed")

-- [[ BEGINNING OF YOUR FULL SCRIPT ]]

getfenv().LPH_NO_VIRTUALIZE = function(f)
    return f
end

_G.check = function()
    return true
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local TeleportService = game:GetService("TeleportService")
local LocalPlayer = Players.LocalPlayer

local cType = clonefunction(type)
local old; old = hookfunction(type, newcclosure(function(...)
    local success, result = pcall(cType, ...)
    if not success then
        error(result, 0)
    end
    if not checkcaller() then
        local args = {...}
        return old(unpack(args))
    end
    return old(...)
end))

for _, tbl in pairs(getgc(true)) do
    if type(tbl) == "table" and rawget(tbl, "react") then
        if rawget(tbl, "overlapCheck") then
            rawset(tbl, "overlapCheck", function()
                return true
            end)
        end
        if rawget(tbl, "checkDistance") then
            rawset(tbl, "checkDistance", function()
                return true
            end)
        end
        if rawget(tbl, "validateTouch") then
            rawset(tbl, "validateTouch", function()
                return true
            end)
        end
    end
end

for _, tbl in pairs(getgc(true)) do
    if type(tbl) == "table" and rawget(tbl, "antiCheat") then
        rawset(tbl, "antiCheat", function()
            return
        end)
    end
end

local mt = getrawmetatable(Vector3.new())
local oldIndex = mt.__index

local safeCaller = newcclosure(LPH_NO_VIRTUALIZE(function(self, key)
    if key == "Magnitude" and typeof(self) == "Vector3" then
        local trace = debug.traceback()
        if trace:find("react") or trace:find("gkReact") or trace:find("catch") or trace:find("anticheat") or trace:find("antiCheat") then
            local origMagnitude = oldIndex(self, key)
            local limit = 2.5
            return math.min(origMagnitude, limit)
        end
    end
    return oldIndex(self, key)
end))

setreadonly(mt, false)
local original = mt["__index"]

mt["__index"] = newcclosure(function(...)
    if debug.info(2, "s") ~= "[C]" and debug.info(3, "s") ~= "[C]" then
        return original(...)
    end
    return safeCaller(...)
end)

setreadonly(mt, true)

local old_invoke
old_invoke = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(self, ...)
    if game.PlaceId == 132985434722615 then
        return old_invoke(self, ...)
    end

    local args = { ... }

    local success, result = pcall(function()
        if type(args[3]) == "table" then
            local t = {}
            for k, v in pairs(args[3]) do
                if k ~= "forceNetworkOwner" then
                    t[k] = v
                end
            end
            t.ignoreReactDecline = true
            t.specialTool = true
            t.bypassAntiCheat = true

            args[3] = t
        end

        return old_invoke(self, unpack(args))
    end)

    if success then
        return result
    end
end)

local old_fire
old_fire = hookfunction(Instance.new("RemoteEvent").FireServer, function(self, ...)
    if game.PlaceId == 132985434722615 then
        return old_fire(self, ...)
    end

    local args = { ... }

    pcall(function()
        if type(args[3]) == "table" then
            local t = {}
            for k, v in pairs(args[3]) do
                if k ~= "forceNetworkOwner" then
                    t[k] = v
                end
            end
            t.ignoreReactDecline = true
            t.specialTool = true
            t.bypassAntiCheat = true

            args[3] = t
        end
    end)

    return old_fire(self, unpack(args))
end)

local ankleModule, originalAnkle
for _, tbl in ipairs(getgc(true)) do
    if type(tbl) == "table" and typeof(rawget(tbl, "ankle")) == "function" then
        ankleModule = tbl
        originalAnkle = tbl.ankle

        tbl.ankle = function(...)
            if _G.Opts and _G.Opts.anti_ankle then
                return
            end
            return originalAnkle(...)
        end
        break
    end
end

local function GetHandshake()
    return {
        ["key1"] = tick(),
        ["key2"] = Players.LocalPlayer.UserId,
        ["key3"] = os.clock()
    }
end

local Net = {
    Send = function(Self, ...)
        return getrenv()._G._references.RemoteEvent:FireServer(GetHandshake(), ...)
    end,

    Fetch = function(Self, ...)
        return getrenv()._G._references.RemoteFunction:InvokeServer(GetHandshake(), ...)
    end
}

_G.Opts = _G.Opts or {}
_G.Opts.reach = _G.Opts.reach or false
_G.Opts.comp_reach = _G.Opts.comp_reach or false
_G.Opts.reach_x = _G.Opts.reach_x or 7.5
_G.Opts.reach_y = _G.Opts.reach_y or 7.5
_G.Opts.reach_z = _G.Opts.reach_z or 7.5
_G.Opts.offset_x = _G.Opts.offset_x or 0
_G.Opts.offset_y = _G.Opts.offset_y or 0
_G.Opts.offset_z = _G.Opts.offset_z or 0
_G.Opts.inf_stamina = _G.Opts.inf_stamina or false
_G.Opts.anti_ankle = _G.Opts.anti_ankle or false
_G.Opts.reach_visualizer_enabled = _G.Opts.reach_visualizer_enabled or false
_G.Opts.box_transparency = _G.Opts.box_transparency or 0.5
_G.Opts.visualizer_material = _G.Opts.visualizer_material or "ForceField"
_G.Opts.ball_predictor = _G.Opts.ball_predictor or false
_G.Opts.ball_predict_color = _G.Opts.ball_predict_color or Color3.fromRGB(100, 180, 255)
_G.Opts.auto_top_bins = _G.Opts.auto_top_bins or false
_G.Opts.auto_top_bins_power = _G.Opts.auto_top_bins_power or 200
_G.Opts.auto_top_bins_curve = _G.Opts.auto_top_bins_curve or 0.3
_G.Opts.auto_top_bins_corner = _G.Opts.auto_top_bins_corner or "Top Left"
_G.Opts.auto_top_bins_trail = _G.Opts.auto_top_bins_trail or false
_G.Opts.anti_votekick = _G.Opts.anti_votekick or false
_G.Opts.anti_out = _G.Opts.anti_out or false

local cBalls = {}

for _, v in pairs(CollectionService:GetTagged("Ball")) do
    if v and v:IsA("BasePart") then
        table.insert(cBalls, v)
    end
end

CollectionService:GetInstanceAddedSignal("Ball"):Connect(function(o)
    if o and o:IsA("BasePart") then
        table.insert(cBalls, o)
    end
end)

CollectionService:GetInstanceRemovedSignal("Ball"):Connect(function(o)
    local i = table.find(cBalls, o)
    if i then
        table.remove(cBalls, i)
    end
end)

local function getClosestBall()
    if #cBalls == 0 then
        return nil
    end

    local character = LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")

    if not hrp then
        return cBalls[1]
    end

    local closestBall, closestDistance = nil, math.huge

    for _, ball in pairs(cBalls) do
        if ball and ball.Parent then
            local distance = (ball.Position - hrp.Position).Magnitude
            if distance < closestDistance then
                closestDistance, closestBall = distance, ball
            end
        end
    end

    return closestBall or cBalls[1]
end

local reachConn
local visualizerPart = nil
local cornerPositions = {}
local selectedTargetCFrame = nil
local trailSegments = {}
local activePaths = {}

local function quadraticBezier(t, p0, p1, p2)
    return (1 - t)^2 * p0 + 2 * (1 - t) * t * p1 + t^2 * p2
end

local function getAimTeam()
    if not LocalPlayer.Team then return "Home" end
    local team = string.split(LocalPlayer.Team.Name, " ")[1]
    return (team == "Home" and "Away") or "Home"
end

local function getAimGoal()
    for _, obj in pairs(Workspace.game:GetChildren()) do
        if obj.Name == "system" and obj:FindFirstChild("goal") then
            return obj.goal[getAimTeam()]
        end
    end
end

local function updateCornerPositions()
    local goal = getAimGoal()
    if not goal or not goal:IsA("BasePart") then
        return
    end

    local goalSize = goal.Size
    local goalCFrame = goal.CFrame

    local halfWidth = goalSize.X / 2.2
    local halfHeight = goalSize.Y / 2.2

    cornerPositions["Top Left"] = goalCFrame * CFrame.new(-halfWidth, halfHeight, 0)
    cornerPositions["Top Right"] = goalCFrame * CFrame.new(halfWidth, halfHeight, 0)
    cornerPositions["Bottom Left"] = goalCFrame * CFrame.new(-halfWidth, -halfHeight, 0)
    cornerPositions["Bottom Right"] = goalCFrame * CFrame.new(halfWidth, -halfHeight, 0)

    selectedTargetCFrame = cornerPositions[_G.Opts.auto_top_bins_corner]
end

local function createFake(ball)
    local fake = ball:Clone()
    fake.Parent = Workspace
    fake.Transparency = 1
    fake.Name = "FakeBall"
    fake.CanCollide = false
    CollectionService:RemoveTag(fake, "Ball")

    for _, child in pairs(fake:GetChildren()) do
        if child.Name == "network" or child.Name == "replication" or child.Name == "properties" then
            child:Destroy()
        end
    end
    
    local ncc = Instance.new("NoCollisionConstraint", fake)
    ncc.Part0 = fake
    ncc.Part1 = ball

    game:GetService("Debris"):AddItem(fake, 5)
    return fake
end

local function createBezierTrail(ball, points, lifeTime)
    if not _G.Opts.auto_top_bins_trail then return end

    trailSegments[ball] = trailSegments[ball] or {}
    local count = #points
    if count < 2 then return end

    for i = 1, count - 1 do
        local p0 = points[i]
        local p1 = points[i + 1]

        local part0 = Instance.new("Part")
        part0.Size = Vector3.new(0.1, 0.1, 0.1)
        part0.Anchored = true
        part0.CanCollide = false
        part0.Transparency = 1
        part0.CFrame = CFrame.new(p0)
        part0.Parent = Workspace

        local part1 = Instance.new("Part")
        part1.Size = Vector3.new(0.1, 0.1, 0.1)
        part1.Anchored = true
        part1.CanCollide = false
        part1.Transparency = 1
        part1.CFrame = CFrame.new(p1)
        part1.Parent = Workspace

        local att0 = Instance.new("Attachment")
        att0.Parent = part0

        local att1 = Instance.new("Attachment")
        att1.Parent = part1

        local beam = Instance.new("Beam")
        beam.Attachment0 = att0
        beam.Attachment1 = att1

        local alpha = (i - 1) / (count - 1)
        local c = Color3.new(alpha, 1 - alpha, 0)
        beam.Color = ColorSequence.new(c, c)
        beam.Width0 = 0.4
        beam.Width1 = 0.4
        beam.FaceCamera = true
        beam.Transparency = NumberSequence.new(0)
        beam.Parent = part0

        table.insert(trailSegments[ball], {
            part0 = part0,
            part1 = part1,
            beam = beam,
        })

        game:GetService("Debris"):AddItem(part0, lifeTime + 1)
        game:GetService("Debris"):AddItem(part1, lifeTime + 1)

        task.spawn(function()
            local fadeTime = lifeTime
            local startTime = tick()
            while beam and beam.Parent and part0 and part0.Parent and part1 and part1.Parent do
                local tFade = (tick() - startTime) / fadeTime
                if tFade >= 1 then
                    break
                end
                beam.Transparency = NumberSequence.new(tFade)
                RunService.Heartbeat:Wait()
            end
            if part0 and part0.Parent then
                part0:Destroy()
            end
            if part1 and part1.Parent then
                part1:Destroy()
            end
        end)
    end
end

local function updateVis()
    if visualizerPart and visualizerPart.Parent then
        visualizerPart.Size = Vector3.new(_G.Opts.reach_x, _G.Opts.reach_y, _G.Opts.reach_z)
        visualizerPart.Transparency = _G.Opts.box_transparency
        visualizerPart.Material = Enum.Material[_G.Opts.visualizer_material] or Enum.Material.ForceField
        local weld = visualizerPart:FindFirstChild("Weld")
        if weld then
            weld.C0 = CFrame.new(_G.Opts.offset_x, _G.Opts.offset_y, _G.Opts.offset_z)
        end
    end
end

local function createVisualizer()
    if visualizerPart then
        if visualizerPart.Parent then
            visualizerPart:Destroy()
        end
        visualizerPart = nil
    end

    local old = Workspace:FindFirstChild("ReachVisualizer")
    if old then
        old:Destroy()
    end

    local character = LocalPlayer.Character
    if not character then
        return
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return
    end

    visualizerPart = Instance.new("Part")
    visualizerPart.Name = "ReachVisualizer"
    visualizerPart.Anchored = false
    visualizerPart.CanCollide = false
    visualizerPart.CanTouch = false
    visualizerPart.Massless = true
    visualizerPart.CastShadow = false
    visualizerPart.Material = Enum.Material.ForceField
    visualizerPart.Color = Color3.fromRGB(0, 255, 255)
    visualizerPart.Parent = Workspace

    local weld = Instance.new("Weld")
    weld.Name = "Weld"
    weld.Part0 = hrp
    weld.Part1 = visualizerPart
    weld.C0 = CFrame.new(_G.Opts.offset_x, _G.Opts.offset_y, _G.Opts.offset_z)
    weld.Parent = visualizerPart

    updateVis()
end

local function destroyVisualizer()
    if visualizerPart then
        visualizerPart:Destroy()
        visualizerPart = nil
    end
end

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if _G.Opts.reach_visualizer_enabled then
        createVisualizer()
    end
end)

local infStamConn
local antiVotekickConn
local outFolderOriginalParent, outFolderRef

local function toggleAntiVotekick(state)
    _G.Opts.anti_votekick = state

    if state then
        if not antiVotekickConn then
            antiVotekickConn = RunService.Heartbeat:Connect(function()
                pcall(function()
                    local voteKickUI = LocalPlayer.PlayerGui.main.voteKick
                    if voteKickUI.Visible and voteKickUI.main.user.Text == LocalPlayer.Name then
                        TeleportService:TeleportToPlaceInstance(game.PlaceId, game.JobId, LocalPlayer)
                    end
                end)
            end)
        end
    else
        if antiVotekickConn then
            antiVotekickConn:Disconnect()
            antiVotekickConn = nil
        end
    end
end

local function toggleAntiOut(state)
    _G.Opts.anti_out = state

    local folder = Workspace:FindFirstChild("game", true)
    folder = folder and folder:FindFirstChild("system", true)
    folder = folder and folder:FindFirstChild("out", true)

    if state then
        if folder and folder.Parent ~= ReplicatedStorage then
            outFolderOriginalParent = folder.Parent
            outFolderRef = folder
            folder.Parent = ReplicatedStorage
        end
    else
        if outFolderRef and outFolderOriginalParent and outFolderRef.Parent ~= outFolderOriginalParent then
            outFolderRef.Parent = outFolderOriginalParent
        end
    end
end

local ballsFolder = CollectionService:GetTagged("BallsFolder")[1]
if ballsFolder then
    ballsFolder.DescendantAdded:Connect(function(bodyVel)
        local character = LocalPlayer.Character
        
        if not _G.Opts.auto_top_bins or not character or not character:FindFirstChild("Kick") then
            return
        end

        if not bodyVel:IsA("BodyVelocity") or not bodyVel.Parent:IsA("BasePart") then
            return
        end

        if not isnetworkowner or not isnetworkowner(bodyVel.Parent) then
            return
        end

        local ball = bodyVel.Parent
        
        if not selectedTargetCFrame then 
            updateCornerPositions()
            if not selectedTargetCFrame then return end
        end

        for _, obj in pairs(ball:GetChildren()) do
            if obj:IsA("BodyMover") then
                obj:Destroy()
            end
        end
        
        local fakeBall = createFake(ball)
        local startPos = fakeBall.Position
        local targetPos = selectedTargetCFrame.Position
        
        local distance = (targetPos - startPos).Magnitude
        local midPoint = (startPos + targetPos) / 2
        local shotDirection = (targetPos - startPos).Unit
        local sideVector = shotDirection:Cross(Vector3.yAxis).Unit
        
        local curveOffset = sideVector * distance * _G.Opts.auto_top_bins_curve
        local heightOffset = Vector3.new(0, distance * 0.15, 0)
        local controlPoint = midPoint + curveOffset + heightOffset
        
        local duration = distance / math.max(1, _G.Opts.auto_top_bins_power)
        local steps = math.max(10, math.ceil(distance / 2))

        local connection
        local deattach
        
        deattach = function()
            if connection then connection:Disconnect() end
            if fakeBall and fakeBall.Parent then fakeBall:Destroy() end
            if activePaths[ball] then activePaths[ball] = nil end
            if trailSegments[ball] then
                for _, seg in ipairs(trailSegments[ball]) do
                    if seg.part0 and seg.part0.Parent then
                        seg.part0:Destroy()
                    end
                    if seg.part1 and seg.part1.Parent then
                        seg.part1:Destroy()
                    end
                end
                trailSegments[ball] = nil
            end
        end

        connection = RunService.Heartbeat:Connect(function()
            if not ball or not ball.Parent or not fakeBall or not fakeBall.Parent then
                deattach()
                return
            end
            ball.CFrame = fakeBall.CFrame
            ball.RotVelocity = Vector3.zero
        end)
        
        activePaths[ball] = deattach

        local points = {}
        for i = 0, steps do
            local t = i / steps
            local point = quadraticBezier(t, startPos, controlPoint, targetPos)
            table.insert(points, point)
        end

        if _G.Opts.auto_top_bins_trail then
            createBezierTrail(ball, points, duration)
        end

        task.spawn(function()
            for i = 1, steps do
                if not fakeBall or not fakeBall.Parent then break end
                
                local point = points[i + 1] or points[#points]
                local tween = TweenService:Create(fakeBall, TweenInfo.new(duration / steps, Enum.EasingStyle.Linear), {
                    Position = point
                })
                tween:Play()
                tween.Completed:Wait()
            end

            if ball and ball.Parent and fakeBall and fakeBall.Parent then
                ball.CFrame = fakeBall.CFrame
                local continueSpeedFactor = 0.4
                local continueSpeed = _G.Opts.auto_top_bins_power * continueSpeedFactor
                ball.Velocity = shotDirection * continueSpeed
                ball.RotVelocity = Vector3.new(0, math.rad(360), 0)
            end
            
            deattach()
        end)
    end)
end

RunService.Heartbeat:Connect(function()
    pcall(function()
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if _G.Opts.ball_predictor and #cBalls > 0 then
            for _, v in pairs(Workspace:GetChildren()) do
                if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("RephonPred") then 
                    v:Destroy() 
                end
            end

            local balls = {}
            for _, ball in pairs(cBalls) do
                if ball and ball.Parent then
                    table.insert(balls, ball)
                end
            end

            if #balls == 0 then return end

            table.sort(balls, function(a, b)
                return (a.Position - hrp.Position).Magnitude < (b.Position - hrp.Position).Magnitude
            end)

            local ball = balls[1]
            local vel = ball.AssemblyLinearVelocity or ball.Velocity
            if not ball or vel.Magnitude < 5 then return end

            local PHYSICS_STEP = 0.008333333333333333
            local MAX_SIMULATION_TIME = 4
            local MAX_BOUNCES = 3
            local STOP_SPEED = 1
            local MAX_STEP_DISTANCE = 6
            local PUSHOUT = 0.03
            local DRAG_COEFFICIENT = 0.05
            local DEFAULT_RESTITUTION = 0.7
            local DEFAULT_FRICTION = 0.15

            local position = ball.Position
            local velocity = vel
            local mass = ball.AssemblyMass or 1
            local gravity = Vector3.new(0, -Workspace.Gravity, 0)

            local bodyVelocity = ball:FindFirstChildOfClass("BodyVelocity")
            local bodyForce = ball:FindFirstChildOfClass("BodyForce")
            local vectorForce = ball:FindFirstChildOfClass("VectorForce", true)
            local linearVelocity = ball:FindFirstChildOfClass("LinearVelocity", true)

            local initialBodyVelocity = bodyVelocity and bodyVelocity.Velocity or Vector3.zero
            local initialBodyForce = bodyForce and bodyForce.Force or Vector3.zero
            local initialVectorForce = vectorForce and vectorForce.Force or Vector3.zero
            local initialLinearVelocity = linearVelocity and (linearVelocity.VectorVelocity or linearVelocity.LineVelocity) or nil

            local rayParams = RaycastParams.new()
            rayParams.FilterType = Enum.RaycastFilterType.Exclude
            rayParams.FilterDescendantsInstances = { ball }

            local function dragForce(v)
                local m = v.Magnitude
                if DRAG_COEFFICIENT <= 0 or m < 1e-3 then
                    return Vector3.zero
                end
                return -v.Unit * (m * m) * DRAG_COEFFICIENT
            end

            local points = {}
            local bounces = 0
            local currentTime = 0

            while currentTime < MAX_SIMULATION_TIME and #points < 600 do
                table.insert(points, position)

                local dt = PHYSICS_STEP
                local moveDist = velocity.Magnitude * dt

                if moveDist > MAX_STEP_DISTANCE then
                    dt = math.max(MAX_STEP_DISTANCE / math.max(velocity.Magnitude, 1e-6), 0.0020833333333333333)
                end

                local totalForce = gravity * mass + dragForce(velocity)

                if currentTime < 0.3 and bodyVelocity then
                    velocity = initialBodyVelocity
                end

                if currentTime < 1.0 then
                    if bodyForce then
                        totalForce = totalForce + initialBodyForce
                    end
                    if vectorForce then
                        totalForce = totalForce + initialVectorForce
                    end
                    if initialLinearVelocity then
                        velocity = initialLinearVelocity
                    end
                end

                local acceleration = totalForce / mass
                velocity = velocity + (acceleration * dt)
                local displacement = velocity * dt
                local newPos = position + displacement
                local hit = Workspace:Raycast(position, displacement, rayParams)

                if hit then
                    position = hit.Position
                    bounces = bounces + 1
                    local restitution = DEFAULT_RESTITUTION
                    local friction = DEFAULT_FRICTION
                    
                    if hit.Instance and hit.Instance:IsA("BasePart") then
                        local props = hit.Instance.CustomPhysicalProperties
                        if props then
                            restitution = props.Elasticity or restitution
                            friction = props.Friction or friction
                        end
                    end

                    local normal = hit.Normal.Unit
                    local vN = normal * velocity:Dot(normal)
                    local vT = velocity - vN
                    velocity = (-restitution) * vN + (1 - friction) * vT
                    position = position + (normal * PUSHOUT)

                    if bounces > MAX_BOUNCES or velocity.Magnitude < STOP_SPEED then
                        table.insert(points, position)
                        break
                    end
                else
                    position = newPos
                end

                currentTime = currentTime + dt
            end

            if #points == 0 or points[#points] ~= position then
                table.insert(points, position)
            end

            for i = 1, #points - 1 do
                local att0 = Instance.new("Attachment")
                att0.Name = "RephonPredAttach"
                att0.WorldPosition = points[i]
                att0.Parent = Workspace.Terrain

                local att1 = Instance.new("Attachment")
                att1.Name = "RephonPredAttach"
                att1.WorldPosition = points[i + 1]
                att1.Parent = Workspace.Terrain

                local beam = Instance.new("Beam")
                beam.Name = "RephonPred"
                beam.Attachment0 = att0
                beam.Attachment1 = att1
                beam.Color = ColorSequence.new(_G.Opts.ball_predict_color)
                beam.Width0 = 0.3
                beam.Width1 = 0.3
                beam.FaceCamera = true
                beam.Transparency = NumberSequence.new(0.3)
                beam.Parent = Workspace
            end

            task.delay(2, function()
                for _, v in pairs(Workspace:GetChildren()) do
                    if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("RephonPred") then 
                        v:Destroy() 
                    end
                end
            end)
        else
            for _, v in pairs(Workspace:GetChildren()) do
                if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("RephonPred") then 
                    v:Destroy() 
                end
            end
        end
    end)
end)

local Library = loadstring(game:HttpGetAsync("https://github.com/ActualMasterOogway/Fluent-Renewed/releases/latest/download/Fluent.luau"))()
local SaveManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/SaveManager.luau"))()
local InterfaceManager = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/ActualMasterOogway/Fluent-Renewed/master/Addons/InterfaceManager.luau"))()

local Window = Library:CreateWindow{
    Title = "Rephon Hub",
    SubTitle = "V1.0.0",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 525),
    Resize = true,
    MinSize = Vector2.new(400, 380),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightShift
}

local Tabs = {
    Reach = Window:CreateTab{ Title = "Reach", Icon = "box" },
    Player = Window:CreateTab{ Title = "Player", Icon = "user" },
    Ball = Window:CreateTab{ Title = "Ball", Icon = "disc" },
    Misc = Window:CreateTab{ Title = "Misc", Icon = "settings-2" },
    Config = Window:CreateTab{ Title = "Config", Icon = "settings" }
}

Tabs.Reach:CreateToggle("EnableReach", {
	Title = "Enable Reach",
	Default = false,
	Callback = function(state)
        _G.Opts.reach = state
    
        if state and not reachConn then
            reachConn = RunService.Heartbeat:Connect(function()
                if not _G.Opts.reach then return end
    
                local character = LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if not (hrp and #cBalls > 0) then return end
    
                local boxCF = hrp.CFrame * CFrame.new(_G.Opts.offset_x, _G.Opts.offset_y, _G.Opts.offset_z)
                local boxSize = Vector3.new(_G.Opts.reach_x, _G.Opts.reach_y, _G.Opts.reach_z)
    
                local params = OverlapParams.new()
                params.FilterType = Enum.RaycastFilterType.Whitelist
                params.FilterDescendantsInstances = cBalls
    
                local hits = Workspace:GetPartBoundsInBox(boxCF, boxSize, params)
                if #hits == 0 then return end
    
                table.sort(hits, function(a, b)
                    return (a.Position - hrp.Position).Magnitude < (b.Position - hrp.Position).Magnitude
                end)
    
                local ball = hits[1]
                local allowed = true
                
                if _G.Opts.comp_reach then
                    local owner = ball:GetAttribute("networkOwner")
                    allowed = (owner ~= LocalPlayer.UserId)
                end
                
                if not allowed then
                    return
                end
    
                for _, limbName in pairs({ "Head", "Torso", "Collide", "LeftHand", "RightHand", "LeftFoot", "RightFoot" }) do
                    local limb = character:FindFirstChild(limbName)
                    if limb and limb:IsA("BasePart") then
                        pcall(function()
                            firetouchinterest(limb, ball, 0)
                            task.wait()
                            firetouchinterest(limb, ball, 1)
                        end)
                    end
                end
            end)
        elseif not state and reachConn then
            reachConn:Disconnect()
            reachConn = nil
        end
    end
})

Tabs.Reach:CreateToggle("CompReach", {
    Title = "Comp Reach",
    Default = false,
    Callback = function(state)
        _G.Opts.comp_reach = state
    end
})

Tabs.Reach:CreateSlider("ReachX", {
    Title = "Reach X",
    Min = 0, Max = 12, Default = 7.5,
    Rounding = 1,
    Callback = function(s)
        _G.Opts.reach_x = s
        updateVis()
    end
})

Tabs.Reach:CreateSlider("ReachY", {
    Title = "Reach Y",
    Min = 0, Max = 12, Default = 7.5,
    Rounding = 1,
    Callback = function(s)
        _G.Opts.reach_y = s
        updateVis()
    end
})

Tabs.Reach:CreateSlider("ReachZ", {
    Title = "Reach Z",
    Min = 0, Max = 12, Default = 7.5,
    Rounding = 1,
    Callback = function(s)
        _G.Opts.reach_z = s
        updateVis()
    end
})

Tabs.Reach:CreateSlider("OffsetX", {
    Title = "Offset X",
    Min = -10, Max = 10, Default = 0,
    Rounding = 1,
    Callback = function(s)
        _G.Opts.offset_x = s
        updateVis()
    end
})

Tabs.Reach:CreateSlider("OffsetY", {
    Title = "Offset Y",
    Min = -10, Max = 10, Default = 0,
    Rounding = 1,
    Callback = function(s)
        _G.Opts.offset_y = s
        updateVis()
    end
})

Tabs.Reach:CreateSlider("OffsetZ", {
    Title = "Offset Z",
    Min = -10, Max = 10, Default = 0,
    Rounding = 1,
    Callback = function(s)
        _G.Opts.offset_z = s
        updateVis()
    end
})

Tabs.Reach:CreateToggle("ReachVisualizer", {
    Title = "Reach Visualizer",
    Default = false,
    Callback = function(state)
        _G.Opts.reach_visualizer_enabled = state
        if state then
            task.wait(0.1)
            createVisualizer()
        else
            destroyVisualizer()
        end
    end
})

Tabs.Reach:CreateSlider("BoxTransparency", {
    Title = "Box Transparency",
    Min = 0, Max = 1, Default = 0.5,
    Rounding = 2,
    Callback = function(s)
        _G.Opts.box_transparency = s
        updateVis()
    end
})

Tabs.Reach:CreateDropdown("VisualizerMaterial", {
    Title = "Material",
    Default = "ForceField",
    Values = {"ForceField", "Neon", "Glass", "Plastic", "Metal"},
    Multi = false,
    Callback = function(v)
        _G.Opts.visualizer_material = v
        updateVis()
    end
})

Tabs.Player:CreateToggle("InfiniteStamina", {
    Title = "Infinite Stamina",
    Default = false,
    Callback = function(state)
        _G.Opts.inf_stamina = state
    
        if state and not infStamConn then
            infStamConn = RunService.Heartbeat:Connect(function()
                if not _G.Opts.inf_stamina then return end
    
                pcall(function()
                    local stam = LocalPlayer:FindFirstChild("PlayerScripts", true)
                        :FindFirstChild("controllers", true)
                        :FindFirstChild("movementController", true)
                        :FindFirstChild("stamina", true)
    
                    if stam then
                        stam.Value = 100
                    end
                end)
            end)
        elseif not state and infStamConn then
            infStamConn:Disconnect()
            infStamConn = nil
        end
    end
})

Tabs.Player:CreateToggle("AntiAnkle", {
    Title = "Anti Ankle",
    Default = false,
    Callback = function(state)
        _G.Opts.anti_ankle = state
    end
})

Tabs.Player:CreateToggle("AntiVotekick", {
    Title = "Anti Votekick",
    Default = false,
    Callback = function(state)
        toggleAntiVotekick(state)
    end
})

Tabs.Player:CreateToggle("AntiOut", {
    Title = "Anti Out",
    Default = false,
    Callback = function(state)
        toggleAntiOut(state)
    end
})

Tabs.Ball:CreateToggle("BallPredictor", {
    Title = "Ball Predictor",
    Default = false,
    Callback = function(state)
        _G.Opts.ball_predictor = state
    end
})

Tabs.Ball:CreateToggle("AutoTopBins", {
    Title = "Auto Top Bins",
    Default = false,
    Callback = function(state)
        _G.Opts.auto_top_bins = state
        if state then
            updateCornerPositions()
        end
    end
})

Tabs.Ball:CreateSlider("ShotPower", {
    Title = "Shot Power",
    Min = 150, Max = 400, Default = 200,
    Rounding = 0,
    Callback = function(v)
        _G.Opts.auto_top_bins_power = v
    end
})

Tabs.Ball:CreateSlider("Curve", {
    Title = "Curve",
    Min = -1.5, Max = 1.5, Default = 0.3,
    Rounding = 2,
    Callback = function(v)
        _G.Opts.auto_top_bins_curve = v
    end
})

Tabs.Ball:CreateDropdown("TargetCorner", {
    Title = "Target Corner",
    Values = {"Top Left", "Top Right", "Bottom Left", "Bottom Right"},
    Multi = false,
    Default = 1,
    Callback = function(v)
        _G.Opts.auto_top_bins_corner = v
        updateCornerPositions()
    end
})

Tabs.Ball:CreateToggle("ShowTrail", {
    Title = "Show Trail",
    Default = false,
    Callback = function(state)
        _G.Opts.auto_top_bins_trail = state
    end
})

getgenv().PostieSpooferConfig = {
    Delay = 0,
    RealLag = false
}

task.spawn(function()
    local Postie = nil

    for _, v in pairs(getgc(true)) do
        if type(v) == "table" then
            if rawget(v, "SetCallback") and rawget(v, "InvokeClient") and rawget(v, "InvokeServer") then
                Postie = v
                break
            end
        end
    end

    if not Postie then 
        return
    end

    Postie.SetCallback("Ping", function(...)
        local cfg = getgenv().PostieSpooferConfig
        if cfg.Delay > 0 then
            task.wait(cfg.Delay)
        end
        return true
    end)

    if not getgenv().PostieOriginalInvoke then
        getgenv().PostieOriginalInvoke = Postie.InvokeServer
        
        Postie.InvokeServer = function(self, ...)
            local cfg = getgenv().PostieSpooferConfig
            if cfg.RealLag and cfg.Delay > 0 then
                task.wait(cfg.Delay)
            end
            return getgenv().PostieOriginalInvoke(self, ...)
        end
    end
end)

Tabs.Misc:CreateToggle("RealLag", {
    Title = "Real Lag (Affects Gameplay)",
    Default = false,
    Callback = function(state)
        getgenv().PostieSpooferConfig.RealLag = state
    end
})

Tabs.Misc:CreateInput("PingSpoofAmount", {
    Title = "Spoof Ping (ms)",
    Default = "0",
    Placeholder = "e.g. 150",
    Numeric = true,
    Finished = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            getgenv().PostieSpooferConfig.Delay = num / 1000
        else
            getgenv().PostieSpooferConfig.Delay = 0
        end
    end
})

Tabs.Misc:CreateButton{
    Title = "Rejoin Server",
    Callback = function()
        TeleportService:Teleport(game.PlaceId, LocalPlayer)
    end
}

Tabs.Misc:CreateButton{
    Title = "Copy Game ID",
    Callback = function()
        setclipboard(tostring(game.PlaceId))
        Library:Notify{
            Title = "Copied!",
            Content = "Game ID copied to clipboard",
            Duration = 3
        }
    end
}

SaveManager:SetLibrary(Library)
InterfaceManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes{}

InterfaceManager:SetFolder("RephonHub")
SaveManager:SetFolder("RephonHub/MainConfig")

InterfaceManager:BuildInterfaceSection(Tabs.Config)
SaveManager:BuildConfigSection(Tabs.Config)

Window:SelectTab(1)

Library:Notify{
    Title = "Rephon Hub",
    Content = "Successfully loaded with Rephon!",
    Duration = 3
}
