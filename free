--[[ 
    Rephon Hub - Compkiller UI Version 
    Converted for User
]]

-- // 1. CORE LOGIC & BYPASSES (UNTOUCHED) \\ --

getfenv().LPH_NO_VIRTUALIZE = function(f)
    return f
end

_G.check = function()
    return true
end

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local CollectionService = game:GetService("CollectionService")
local Workspace = game:GetService("Workspace")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

local cType = clonefunction(type)
local old; old = hookfunction(type, newcclosure(function(...)
    local success, result = pcall(cType, ...)

    if not success then
        error(result, 0)
    end

    if not checkcaller() then
        local args = {...}
        return old(unpack(args))
    end

    return old(...)
end))

for _, tbl in pairs(getgc(true)) do
    if type(tbl) == "table" and rawget(tbl, "react") then
        if rawget(tbl, "overlapCheck") then
            rawset(tbl, "overlapCheck", function()
                return true
            end)
        end
        if rawget(tbl, "checkDistance") then
            rawset(tbl, "checkDistance", function()
                return true
            end)
        end
        if rawget(tbl, "validateTouch") then
            rawset(tbl, "validateTouch", function()
                return true
            end)
        end
    end
end

for _, tbl in pairs(getgc(true)) do
    if type(tbl) == "table" and rawget(tbl, "antiCheat") then
        rawset(tbl, "antiCheat", function()
            return
        end)
    end
end

local mt = getrawmetatable(Vector3.new())
local oldIndex = mt.__index

local safeCaller = newcclosure(LPH_NO_VIRTUALIZE(function(self, key)
    if key == "Magnitude" and typeof(self) == "Vector3" then
        local trace = debug.traceback()
        if trace:find("react") or trace:find("gkReact") or trace:find("catch") or trace:find("anticheat") or trace:find("antiCheat") then
            local origMagnitude = oldIndex(self, key)
            local limit = 2.5
            return math.min(origMagnitude, limit)
        end
    end
    return oldIndex(self, key)
end))

setreadonly(mt, false)
local original = mt["__index"]

mt["__index"] = newcclosure(function(...)
    if debug.info(2, "s") ~= "[C]" and debug.info(3, "s") ~= "[C]" then
        return original(...)
    end
    return safeCaller(...)
end)

setreadonly(mt, true)

local old_invoke
old_invoke = hookfunction(Instance.new("RemoteFunction").InvokeServer, function(self, ...)
    if game.PlaceId == 132985434722615 then
        return old_invoke(self, ...)
    end

    local args = { ... }

    local success, result = pcall(function()
        if type(args[3]) == "table" then
            local t = {}
            for k, v in pairs(args[3]) do
                if k ~= "forceNetworkOwner" then
                    t[k] = v
                end
            end
            t.ignoreReactDecline = true
            t.specialTool = true
            t.bypassAntiCheat = true

            args[3] = t
        end

        return old_invoke(self, unpack(args))
    end)

    if success then
        return result
    end
end)

local old_fire
old_fire = hookfunction(Instance.new("RemoteEvent").FireServer, function(self, ...)
    if game.PlaceId == 132985434722615 then
        return old_fire(self, ...)
    end

    local args = { ... }

    pcall(function()
        if type(args[3]) == "table" then
            local t = {}
            for k, v in pairs(args[3]) do
                if k ~= "forceNetworkOwner" then
                    t[k] = v
                end
            end
            t.ignoreReactDecline = true
            t.specialTool = true
            t.bypassAntiCheat = true

            args[3] = t
        end
    end)

    return old_fire(self, unpack(args))
end)

local ankleModule, originalAnkle
for _, tbl in ipairs(getgc(true)) do
    if type(tbl) == "table" and typeof(rawget(tbl, "ankle")) == "function" then
        ankleModule = tbl
        originalAnkle = tbl.ankle

        tbl.ankle = function(...)
            if _G.Opts and _G.Opts.anti_ankle then
                return
            end
            return originalAnkle(...)
        end
        break
    end
end

local function GetHandshake()
    return {
        ["key1"] = tick(),
        ["key2"] = Players.LocalPlayer.UserId,
        ["key3"] = os.clock()
    }
end

local Net = {
    Send = function(Self, ...)
        return getrenv()._G._references.RemoteEvent:FireServer(GetHandshake(), ...)
    end,

    Fetch = function(Self, ...)
        return getrenv()._G._references.RemoteFunction:InvokeServer(GetHandshake(), ...)
    end
}

_G.Opts = _G.Opts or {}
_G.Opts.reach = _G.Opts.reach or false
_G.Opts.comp_reach = _G.Opts.comp_reach or false
_G.Opts.reach_x = _G.Opts.reach_x or 15
_G.Opts.reach_y = _G.Opts.reach_y or 15
_G.Opts.reach_z = _G.Opts.reach_z or 15
_G.Opts.offset_x = _G.Opts.offset_x or 0
_G.Opts.offset_y = _G.Opts.offset_y or 0
_G.Opts.offset_z = _G.Opts.offset_z or 0
_G.Opts.inf_stamina = _G.Opts.inf_stamina or false
_G.Opts.anti_ankle = _G.Opts.anti_ankle or false
_G.Opts.reach_visualizer_enabled = _G.Opts.reach_visualizer_enabled or false
_G.Opts.box_transparency = _G.Opts.box_transparency or 0.5
_G.Opts.auto_goal_target = _G.Opts.auto_goal_target or "Enemy"
_G.Opts.visualizer_material = _G.Opts.visualizer_material or "ForceField"
_G.Opts.ball_predictor = _G.Opts.ball_predictor or false
_G.Opts.ball_predict_color = _G.Opts.ball_predict_color or Color3.fromRGB(100, 180, 255)
_G.Opts.auto_top_bins = _G.Opts.auto_top_bins or false

local cBalls = {}

for _, v in pairs(CollectionService:GetTagged("Ball")) do
    if v and v:IsA("BasePart") then
        table.insert(cBalls, v)
    end
end

CollectionService:GetInstanceAddedSignal("Ball"):Connect(function(o)
    if o and o:IsA("BasePart") then
        table.insert(cBalls, o)
    end
end)

CollectionService:GetInstanceRemovedSignal("Ball"):Connect(function(o)
    local i = table.find(cBalls, o)
    if i then
        table.remove(cBalls, i)
    end
end)

local function getClosestBall()
    if #cBalls == 0 then
        return nil
    end

    local character = LocalPlayer.Character
    local hrp = character and character:FindFirstChild("HumanoidRootPart")

    if not hrp then
        return cBalls[1]
    end

    local closestBall, closestDistance = nil, math.huge

    for _, ball in pairs(cBalls) do
        if ball and ball.Parent then
            local distance = (ball.Position - hrp.Position).Magnitude
            if distance < closestDistance then
                closestDistance, closestBall = distance, ball
            end
        end
    end

    return closestBall or cBalls[1]
end

local function getTeamSide()
    local team = LocalPlayer.Team
    if not team then return "Home" end

    local first = string.split(team.Name, " ")[1]
    if first == "Home" or first == "Away" then
        return first
    end
    return "Home"
end

local function getNet(targetEnemy)
    for _, object in ipairs(Workspace:GetChildren()) do
        if object.Name == "pitch" and object:FindFirstChild("nets") then
            local nets = object.nets
            local mySide = getTeamSide()
            local targetSide
            
            if targetEnemy then
                targetSide = (mySide == "Home") and "Away" or "Home"
            else
                targetSide = mySide
            end
            
            if nets:FindFirstChild(targetSide) then
                return nets[targetSide]
            end
        end
    end
end

local function scoreBall()
    local targetEnemy = (_G.Opts.auto_goal_target == "Enemy")
    local net = getNet(targetEnemy)
    
    if not net or not net:FindFirstChild("Collide") then
        return
    end
    
    local collide = net.Collide
    local ball = getClosestBall()
    
    if ball and ball.Parent then
        pcall(function() 
            ball:SetNetworkOwner(LocalPlayer) 
        end)
        
        task.wait(0.05)
        
        ball.CFrame = collide.CFrame
        ball.AssemblyLinearVelocity = Vector3.zero
        ball.AssemblyAngularVelocity = Vector3.zero
        
        ball.Velocity = Vector3.zero
        ball.RotVelocity = Vector3.zero
    end
end

local reachConn
local visualizerPart = nil

local function updateVis()
    if visualizerPart and visualizerPart.Parent then
        visualizerPart.Size = Vector3.new(_G.Opts.reach_x, _G.Opts.reach_y, _G.Opts.reach_z)
        visualizerPart.Transparency = _G.Opts.box_transparency
        visualizerPart.Material = Enum.Material[_G.Opts.visualizer_material] or Enum.Material.ForceField
        local weld = visualizerPart:FindFirstChild("Weld")
        if weld then
            weld.C0 = CFrame.new(_G.Opts.offset_x, _G.Opts.offset_y, _G.Opts.offset_z)
        end
    end
end

local function createVisualizer()
    if visualizerPart then
        if visualizerPart.Parent then
            visualizerPart:Destroy()
        end
        visualizerPart = nil
    end

    local old = Workspace:FindFirstChild("ReachVisualizer")
    if old then
        old:Destroy()
    end

    local character = LocalPlayer.Character
    if not character then
        return
    end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then
        return
    end

    visualizerPart = Instance.new("Part")
    visualizerPart.Name = "ReachVisualizer"
    visualizerPart.Anchored = false
    visualizerPart.CanCollide = false
    visualizerPart.CanTouch = false
    visualizerPart.Massless = true
    visualizerPart.CastShadow = false
    visualizerPart.Material = Enum.Material.ForceField
    visualizerPart.Color = Color3.fromRGB(0, 255, 255)
    visualizerPart.Parent = Workspace

    local weld = Instance.new("Weld")
    weld.Name = "Weld"
    weld.Part0 = hrp
    weld.Part1 = visualizerPart
    weld.C0 = CFrame.new(_G.Opts.offset_x, _G.Opts.offset_y, _G.Opts.offset_z)
    weld.Parent = visualizerPart

    updateVis()
end

local function destroyVisualizer()
    if visualizerPart then
        visualizerPart:Destroy()
        visualizerPart = nil
    end
end

-- // 2. GAMEPLAY LOOPS (UNTOUCHED) \\ --

local infStamConn

local function getAimTeam()
    if not LocalPlayer.Team then return "Home" end
    local team = string.split(LocalPlayer.Team.Name, " ")[1]
    return (team == "Home" and "Away") or "Home"
end

local function getAimGoal()
    for _, obj in pairs(Workspace:GetChildren()) do
        if obj.Name == "pitch" and obj:FindFirstChild("nets") then
            local nets = obj.nets
            local side = getAimTeam()
            if nets:FindFirstChild(side) then
                return nets[side]
            end
        end
    end
end

local activeBallTracking = {}

RunService.Heartbeat:Connect(function()
    if not _G.Opts.auto_top_bins then return end
    
    pcall(function()
        local char = LocalPlayer.Character
        if not char then return end
        
        local hrp = char:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        
        local hasKickTool = false
        for _, tool in pairs(char:GetChildren()) do
            if tool:IsA("Tool") and tool.Name:lower():find("kick") then
                hasKickTool = true
                break
            end
        end
        
        if not hasKickTool then return end
        
        for _, ball in pairs(cBalls) do
            if ball and ball.Parent and not activeBallTracking[ball] then
                local velocity = ball.AssemblyLinearVelocity or ball.Velocity
                
                if velocity.Magnitude > 10 then
                    local distanceToBall = (ball.Position - hrp.Position).Magnitude
                    
                    if distanceToBall < 15 then
                        activeBallTracking[ball] = true
                        
                        task.spawn(function()
                            for i = 1, 5 do
                                pcall(function() ball:SetNetworkOwner(LocalPlayer) end)
                                task.wait(0.01)
                            end
                            
                            task.wait(0.1)
                            
                            local goal = getAimGoal()
                            if not goal then 
                                activeBallTracking[ball] = nil
                                return 
                            end
                            
                            local goalCenter = goal.Position
                            local goalSize = goal.Size
                            
                            local targetY = goalCenter.Y + (goalSize.Y / 2)
                            local sideOffset = (goalSize.X / 3.5)
                            local leftOrRight = math.random() > 0.5 and 1 or -1
                            local lateralOffset = goal.CFrame.RightVector * (sideOffset * leftOrRight)
                            
                            local targetPos = Vector3.new(
                                goalCenter.X + lateralOffset.X,
                                targetY,
                                goalCenter.Z + lateralOffset.Z
                            )
                            
                            local direction = (targetPos - ball.Position).Unit
                            local distance = (targetPos - ball.Position).Magnitude
                            local speed = math.clamp(distance * 3, 200, 500)
                            
                            ball.AssemblyLinearVelocity = direction * speed
                            ball.AssemblyAngularVelocity = Vector3.zero
                            
                            if ball:FindFirstChild("BodyVelocity") then
                                ball.BodyVelocity:Destroy()
                            end
                            if ball:FindFirstChild("BodyForce") then
                                ball.BodyForce:Destroy()
                            end
                            
                            local bodyVel = Instance.new("BodyVelocity")
                            bodyVel.Name = "TopBinsVel"
                            bodyVel.MaxForce = Vector3.new(math.huge, math.huge, math.huge)
                            bodyVel.Velocity = direction * speed
                            bodyVel.P = 10000
                            bodyVel.Parent = ball
                            
                            local bodyForce = Instance.new("BodyForce")
                            bodyForce.Name = "TopBinsForce"
                            bodyForce.Force = Vector3.new(0, ball:GetMass() * Workspace.Gravity * 1.8, 0)
                            bodyForce.Parent = ball
                            
                            task.delay(3, function()
                                if bodyVel and bodyVel.Parent then bodyVel:Destroy() end
                                if bodyForce and bodyForce.Parent then bodyForce:Destroy() end
                                activeBallTracking[ball] = nil
                            end)
                        end)
                    end
                end
            end
        end
    end)
end)

RunService.Heartbeat:Connect(function()
    pcall(function()
        local hrp = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end

        if _G.Opts.ball_predictor and #cBalls > 0 then
            for _, v in pairs(Workspace:GetChildren()) do
                if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("RephonPred") then 
                    v:Destroy() 
                end
            end

            local balls = {}
            for _, ball in pairs(cBalls) do
                if ball and ball.Parent then
                    table.insert(balls, ball)
                end
            end

            if #balls == 0 then return end

            table.sort(balls, function(a, b)
                return (a.Position - hrp.Position).Magnitude < (b.Position - hrp.Position).Magnitude
            end)

            local ball = balls[1]
            if not ball or ball.AssemblyLinearVelocity.Magnitude < 5 then return end

            local pos = ball.Position
            local vel = ball.AssemblyLinearVelocity
            local grav = Workspace.Gravity
            local ground = hrp.Position.Y - 2
            local points = {}

            for i = 1, 25 do
                local t = i * 0.1
                local futurePos = pos + (vel * t) + Vector3.new(0, -0.5 * grav * t * t, 0)
                if futurePos.Y <= ground then
                    table.insert(points, Vector3.new(futurePos.X, ground, futurePos.Z))
                    break
                else
                    table.insert(points, futurePos)
                end
            end

            if #points < 2 then return end

            for i = 1, #points - 1 do
                local att0 = Instance.new("Attachment")
                att0.Name = "RephonPredAttach"
                att0.WorldPosition = points[i]
                att0.Parent = Workspace.Terrain

                local att1 = Instance.new("Attachment")
                att1.Name = "RephonPredAttach"
                att1.WorldPosition = points[i + 1]
                att1.Parent = Workspace.Terrain

                local beam = Instance.new("Beam")
                beam.Name = "RephonPred"
                beam.Attachment0 = att0
                beam.Attachment1 = att1
                beam.Color = ColorSequence.new(_G.Opts.ball_predict_color)
                beam.Width0 = 0.3
                beam.Width1 = 0.3
                beam.FaceCamera = true
                beam.Transparency = NumberSequence.new(0.3)
                beam.Parent = Workspace
            end

            task.delay(2, function()
                for _, v in pairs(Workspace:GetChildren()) do
                    if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("RephonPred") then 
                        v:Destroy() 
                    end
                end
            end)
        else
            for _, v in pairs(Workspace:GetChildren()) do
                if (v:IsA("Beam") or v:IsA("Attachment")) and v.Name:match("RephonPred") then 
                    v:Destroy() 
                end
            end
        end
    end)
end)

-- // 3. COMPKILLER UI IMPLEMENTATION \\ --

local Compkiller = loadstring(game:HttpGet("https://raw.githubusercontent.com/4lpaca-pin/CompKiller/refs/heads/main/src/source.luau"))();

-- Config Manager
local ConfigManager = Compkiller:ConfigManager({
	Directory = "RephonHub",
	Config = "MainConfig"
});

-- Loader
Compkiller:Loader("rbxassetid://120245531583106", 2).yield();

-- Window
local Window = Compkiller.new({
	Name = "REPHON HUB",
	Keybind = "RightShift",
	Logo = "rbxassetid://120245531583106",
	Scale = Compkiller.Scale.Window,
	TextSize = 15,
});

-- Watermark
local Watermark = Window:Watermark();
Watermark:AddText({ Icon = "user", Text = LocalPlayer.Name });
Watermark:AddText({ Icon = "clock", Text = Compkiller:GetDate() });

-- // TAB 1: REACH \\ --
local ReachTab = Window:DrawTab({
	Name = "Reach",
	Icon = "box", -- Assuming box icon exists
	Type = "Double", -- Split into left/right sections
    EnableScrolling = true
});

local ReachLeft = ReachTab:DrawSection({ Name = "Reach Settings", Position = "left" });
local ReachRight = ReachTab:DrawSection({ Name = "Visuals & Offset", Position = "right" });

-- Reach Toggle
ReachLeft:AddToggle({
	Name = "Enable Reach",
    Flag = "Reach_Toggle",
	Default = false,
	Callback = function(state)
        _G.Opts.reach = state
    
        if state and not reachConn then
            reachConn = RunService.Heartbeat:Connect(function()
                if not _G.Opts.reach then return end
    
                local character = LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if not (hrp and #cBalls > 0) then return end
    
                local boxCF = hrp.CFrame * CFrame.new(_G.Opts.offset_x, _G.Opts.offset_y, _G.Opts.offset_z)
                local boxSize = Vector3.new(_G.Opts.reach_x, _G.Opts.reach_y, _G.Opts.reach_z)
    
                local params = OverlapParams.new()
                params.FilterType = Enum.RaycastFilterType.Whitelist
                params.FilterDescendantsInstances = cBalls
    
                local hits = Workspace:GetPartBoundsInBox(boxCF, boxSize, params)
                if #hits == 0 then return end
    
                table.sort(hits, function(a, b)
                    return (a.Position - hrp.Position).Magnitude < (b.Position - hrp.Position).Magnitude
                end)
    
                local ball = hits[1]
                local allowed = true
                
                if _G.Opts.comp_reach then
                    local owner = ball:GetAttribute("networkOwner")
                    allowed = (owner ~= LocalPlayer.UserId)
                end
                
                if not allowed then
                    return
                end
    
                for _, limbName in pairs({ "Head", "Torso", "Collide", "LeftHand", "RightHand", "LeftFoot", "RightFoot" }) do
                    local limb = character:FindFirstChild(limbName)
                    if limb and limb:IsA("BasePart") then
                        pcall(function()
                            firetouchinterest(limb, ball, 0)
                            task.wait()
                            firetouchinterest(limb, ball, 1)
                        end)
                    end
                end
            end)
        elseif not state and reachConn then
            reachConn:Disconnect()
            reachConn = nil
        end
    end
});

ReachLeft:AddToggle({
    Name = "Comp Reach",
    Flag = "Comp_Reach",
    Default = false,
    Callback = function(state)
        _G.Opts.comp_reach = state
    end
})

ReachLeft:AddSlider({
    Name = "Reach X",
    Flag = "Reach_X",
    Min = 0, Max = 30, Default = 15,
    Callback = function(s)
        _G.Opts.reach_x = s
        updateVis()
    end
})

ReachLeft:AddSlider({
    Name = "Reach Y",
    Flag = "Reach_Y",
    Min = 0, Max = 30, Default = 15,
    Callback = function(s)
        _G.Opts.reach_y = s
        updateVis()
    end
})

ReachLeft:AddSlider({
    Name = "Reach Z",
    Flag = "Reach_Z",
    Min = 0, Max = 30, Default = 15,
    Callback = function(s)
        _G.Opts.reach_z = s
        updateVis()
    end
})

-- Offsets
ReachRight:AddSlider({
    Name = "Offset X",
    Flag = "Offset_X",
    Min = -10, Max = 10, Default = 0,
    Callback = function(s)
        _G.Opts.offset_x = s
        updateVis()
    end
})

ReachRight:AddSlider({
    Name = "Offset Y",
    Flag = "Offset_Y",
    Min = -10, Max = 10, Default = 0,
    Callback = function(s)
        _G.Opts.offset_y = s
        updateVis()
    end
})

ReachRight:AddSlider({
    Name = "Offset Z",
    Flag = "Offset_Z",
    Min = -10, Max = 10, Default = 0,
    Callback = function(s)
        _G.Opts.offset_z = s
        updateVis()
    end
})

-- Visualizer
ReachRight:AddToggle({
    Name = "Reach Visualizer",
    Flag = "Vis_Enabled",
    Default = false,
    Callback = function(state)
        _G.Opts.reach_visualizer_enabled = state
        if state then
            task.wait(0.1)
            createVisualizer()
        else
            destroyVisualizer()
        end
    end
})

ReachRight:AddSlider({
    Name = "Box Transparency",
    Flag = "Box_Trans",
    Min = 0, Max = 1, Default = 0.5,
    Callback = function(s)
        _G.Opts.box_transparency = s
        updateVis()
    end
})

ReachRight:AddDropdown({
    Name = "Material",
    Flag = "Vis_Mat",
    Default = "ForceField",
    Values = {"ForceField", "Neon", "Glass", "Plastic", "Metal"},
    Callback = function(v)
        _G.Opts.visualizer_material = v
        updateVis()
    end
})


-- // TAB 2: PLAYER \\ --
local PlayerTab = Window:DrawTab({
    Name = "Player",
    Icon = "user",
    Type = "Single"
})

local PlayerSection = PlayerTab:DrawSection({ Name = "Character" })

PlayerSection:AddToggle({
    Name = "Infinite Stamina",
    Flag = "Inf_Stam",
    Default = false,
    Callback = function(state)
        _G.Opts.inf_stamina = state
    
        if state and not infStamConn then
            infStamConn = RunService.Heartbeat:Connect(function()
                if not _G.Opts.inf_stamina then return end
    
                pcall(function()
                    local stam = LocalPlayer:FindFirstChild("PlayerScripts", true)
                        :FindFirstChild("controllers", true)
                        :FindFirstChild("movementController", true)
                        :FindFirstChild("stamina", true)
    
                    if stam then
                        stam.Value = 100
                    end
                end)
            end)
        elseif not state and infStamConn then
            infStamConn:Disconnect()
            infStamConn = nil
        end
    end
})

PlayerSection:AddToggle({
    Name = "Anti Ankle",
    Flag = "Anti_Ankle",
    Default = false,
    Callback = function(state)
        _G.Opts.anti_ankle = state
    end
})


-- // TAB 3: BALL \\ --
local BallTab = Window:DrawTab({
    Name = "Ball",
    Icon = "disc", -- Assuming disc/ball icon
    Type = "Double"
})

local BallLeft = BallTab:DrawSection({ Name = "General", Position = "left" })
local BallRight = BallTab:DrawSection({ Name = "Auto Goal", Position = "right" })

BallLeft:AddToggle({
    Name = "Ball Predictor",
    Flag = "Ball_Pred",
    Default = false,
    Callback = function(state)
        _G.Opts.ball_predictor = state
    end
})

BallLeft:AddColorPicker({
    Name = "Predictor Color",
    Flag = "Pred_Color",
    Default = Color3.fromRGB(100, 180, 255),
    Callback = function(v)
        _G.Opts.ball_predict_color = v
    end
})

BallRight:AddToggle({
    Name = "Enable Auto Top Bins",
    Flag = "Top_Bins",
    Default = false,
    Callback = function(state)
        _G.Opts.auto_top_bins = state
    end
})

BallRight:AddDropdown({
    Name = "Goal Target",
    Flag = "Goal_Target",
    Default = "Enemy",
    Values = {"Enemy", "Own"},
    Callback = function(v)
        _G.Opts.auto_goal_target = v
    end
})

BallRight:AddButton({
    Name = "Instant Goal",
    Callback = function()
        scoreBall()
    end
})


-- // TAB 4: CONFIGS & THEMES \\ --
local ConfigUI = Window:DrawConfig({
	Name = "Config",
	Icon = "folder",
	Config = ConfigManager
});

ConfigUI:Init();
